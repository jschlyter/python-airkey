# coding: utf-8

"""
    EVVA AirKey Cloud API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v16.20.7
    Contact: office-wien@evva.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class LockProtocolEvent(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'type': 'str',
        'translations': 'dict(str, str)'
    }

    attribute_map = {
        'type': 'type',
        'translations': 'translations'
    }

    def __init__(self, type=None, translations=None):  # noqa: E501
        """LockProtocolEvent - a model defined in Swagger"""  # noqa: E501
        self._type = None
        self._translations = None
        self.discriminator = None
        if type is not None:
            self.type = type
        if translations is not None:
            self.translations = translations

    @property
    def type(self):
        """Gets the type of this LockProtocolEvent.  # noqa: E501

        Type of event  # noqa: E501

        :return: The type of this LockProtocolEvent.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this LockProtocolEvent.

        Type of event  # noqa: E501

        :param type: The type of this LockProtocolEvent.  # noqa: E501
        :type: str
        """
        allowed_values = ["UNLOCKING_SUCCESSFUL", "UNLOCKING_SUCCESSFUL_VIA_HANDS_FREE", "UNLOCKING_FAILED", "UNLOCKING_FAILED_BLACKLISTED", "UNLOCKING_FAILED_NOT_WHITELISTED", "UNLOCKING_FAILED_CYLINDER_TIME_OUT_OF_SYNC", "UNLOCKING_FAILED_AUTHORIZATION_SIGNATURE_INVALID", "UNLOCKING_FAILED_HOLIDAY_CALENDAR_ACTIVE", "CYLINDER_SYNCHRONIZATION_VIA_CARD_READER", "CYLINDER_SYNCHRONIZATION_VIA_CARD_READER_FAILED", "CYLINDER_SYNCHRONIZATION_VIA_OTA", "CYLINDER_SYNCHRONIZATION_VIA_OTA_FAILED", "CYLINDER_SYNCHRONIZATION_VIA_OTA_AFTER_UNLOCK", "CYLINDER_SYNCHRONIZATION_BY_SUPPORT", "CYLINDER_SYNCHRONIZATION_BY_SUPPORT_FAILED", "KEY_RING_SYNCHRONIZATION_VIA_CARD_READER", "KEY_RING_SYNCHRONIZATION_VIA_CARD_READER_FAILED", "KEY_RING_SYNCHRONIZATION_VIA_OTA", "KEY_RING_SYNCHRONIZATION_VIA_OTA_FAILED", "CREATE_MOBILE_PHONE", "DELETE_MOBILE_PHONE", "ASSIGN_KEY_CARD_TO_CUSTOMER_VIA_CARD_READER", "ASSIGN_KEY_CARD_TO_CUSTOMER_VIA_OTA", "REMOVE_KEY_CARD_FROM_CUSTOMER_VIA_CARD_READER", "REMOVE_KEY_CARD_FROM_CUSTOMER_VIA_OTA", "DEACTIVATION_INITIATED", "DEACTIVATION_COMPLETED", "DEACTIVATION_COMPLETED_BY_SUPPORT", "DEACTIVATION_COMPLETED_IMMEDIATELY", "REACTIVATION_INITIATED", "REACTIVATION_COMPLETED", "REACTIVATION_COMPLETED_BY_SUPPORT", "MOBILE_PHONE_PAIRING_FINALIZED", "MOBILE_PHONE_RE_PAIRING_FINALIZED", "KEYRING_CAP_FILE_UPDATED_VIA_CARD_READER", "KEYRING_CAP_FILE_UPDATED_VIA_OTA", "KEYRING_CAP_FILE_UPDATE_VIA_CARD_READER_FAILED", "KEYRING_CAP_FILE_UPDATE_VIA_OTA_FAILED", "PIN_PROTECTION_ACTIVATED", "PIN_PROTECTION_DEACTIVATED", "CYLINDER_ASSIGNED_TO_CUSTOMER_VIA_CARD_READER", "CYLINDER_ASSIGNED_TO_CUSTOMER_VIA_OTA", "CYLINDER_REMOVED_FROM_CUSTOMER_VIA_CARD_READER", "CYLINDER_REMOVED_FROM_CUSTOMER_VIA_OTA", "SHARED_CYLINDER_CODE_REDEEMED", "CYLINDER_FIRMWARE_UPDATED_VIA_OTA", "CYLINDER_FIRMWARE_UPDATED_VIA_CARD_READER", "CYLINDER_FIRMWARE_UPDATED_BY_SUPPORT", "CYLINDER_FIRMWARE_UPDATED_PARTIALLY_VIA_OTA", "CYLINDER_FIRMWARE_UPDATED_PARTIALLY_VIA_CARD_READER", "CYLINDER_FIRMWARE_UPDATED_PARTIALLY_BY_SUPPORT", "CYLINDER_FIRMWARE_UPDATE_VIA_OTA_FAILED", "CYLINDER_FIRMWARE_UPDATE_VIA_CARD_READER_FAILED", "CYLINDER_FIRMWARE_UPDATE_FAILED_BY_SUPPORT", "CYLINDER_REPLACED_VIA_OTA", "CYLINDER_REPLACED_VIA_CARD_READER", "CYLINDER_REPLACEMENT_VIA_OTA_FAILED", "CYLINDER_REPLACEMENT_VIA_CARD_READER_FAILED", "CYLINDER_INSTALLED_VIA_OTA", "CYLINDER_INSTALLED_VIA_CARD_READER", "CYLINDER_INSTALLATION_VIA_OTA_FAILED", "CYLINDER_INSTALLATION_VIA_CARD_READER_FAILED", "KNOB_REPLACED_VIA_OTA", "KNOB_REPLACED_VIA_CARD_READER", "KNOB_REPLACEMENT_VIA_OTA_FAILED", "KNOB_REPLACEMENT_VIA_CARD_READER_FAILED", "KNOB_INSTALLED_VIA_OTA", "KNOB_INSTALLED_VIA_CARD_READER", "KNOB_INSTALLATION_VIA_OTA_FAILED", "KNOB_INSTALLATION_VIA_CARD_READER_FAILED", "REPLACEMENT_VIA_OTA_FAILED", "REPLACEMENT_VIA_CARD_READER_FAILED", "FAULTY_CYLINDER_REMOVED_VIA_APP", "FAULTY_CYLINDER_REMOVED_VIA_BROWSER", "FAULTY_CYLINDER_REMOVAL_VIA_APP_FAILED", "CYLINDER_SYNCHRONIZATION_AS_PROXY_APP", "CYLINDER_SYNCHRONIZATION_AS_PROXY_APP_FAILED", "KEY_RING_SYNCHRONIZATION_AS_PROXY_APP", "KEY_RING_SYNCHRONIZATION_AS_PROXY_APP_FAILED", "CYLINDER_ASSIGNED_TO_CUSTOMER_AS_PROXY_APP", "KEY_CARD_ASSIGNED_TO_CUSTOMER_AS_PROXY_APP", "CYLINDER_REMOVED_FROM_CUSTOMER_AS_PROXY_APP", "KEY_CARD_REMOVED_FROM_CUSTOMER_AS_PROXY_APP", "MEDIUM_REMOVED_MANUALLY", "MEDIUM_MARKED_FOR_REMOVAL", "KEYRING_CAP_FILE_UPDATED_AS_PROXY_APP", "KEYRING_CAP_FILE_UPDATE_FAILED_AS_PROXY_APP", "CYLINDER_FIRMWARE_UPDATED_AS_PROXY_APP", "CYLINDER_FIRMWARE_UPDATED_PARTIALLY_AS_PROXY_APP", "CYLINDER_FIRMWARE_UPDATE_FAILED_AS_PROXY_APP", "CYLINDER_REPLACED_AS_PROXY_APP", "CYLINDER_REPLACEMENT_FAILED_AS_PROXY_APP", "CYLINDER_INSTALLED_AS_PROXY_APP", "CYLINDER_INSTALLATION_FAILED_AS_PROXY_APP", "KNOB_REPLACED_AS_PROXY_APP", "KNOB_REPLACEMENT_FAILED_AS_PROXY_APP", "KNOB_INSTALLED_AS_PROXY_APP", "KNOB_INSTALLATION_FAILED_AS_PROXY_APP", "REPLACEMENT_FAILED_AS_PROXY_APP", "FAULTY_CYLINDER_REMOVED_AS_PROXY_APP", "FAULTY_CYLINDER_REMOVAL_FAILED_AS_PROXY_APP", "DEACTIVATION_COMPLETED_AS_PROXY_APP", "REACTIVATION_COMPLETED_AS_PROXY_APP", "CYLINDER_LOG_OVERFLOW_POSSIBLE", "MANUAL_PERMANENT_OPENING_STARTED", "MANUAL_PERMANENT_OPENING_STOPPED_MANUALLY", "MANUAL_PERMANENT_OPENING_STOPPED_AUTOMATICALLY", "MANUAL_PERMANENT_OPENING_STOPPED_WEAK_BATTERY", "MANUAL_PERMANENT_OPENING_STOPPED_WRONG_TIME", "AUTOMATIC_PERMANENT_OPENING_STARTED", "AUTOMATIC_PERMANENT_OPENING_STOPPED_MANUALLY", "AUTOMATIC_PERMANENT_OPENING_STOPPED_AUTOMATICALLY", "AUTOMATIC_PERMANENT_OPENING_STOPPED_WEAK_BATTERY", "AUTOMATIC_PERMANENT_OPENING_STOPPED_WRONG_TIME", "AUTOMATIC_PERMANENT_OPENING_STOPPED_HOLIDAY_BEGIN", "UNKNOWN_PERMANENT_OPENING_ACTION", "MANUAL_PERMANENT_OPENING_STOPPED_DUE_TO_FIRMWARE_UPDATE", "AUTOMATIC_PERMANENT_OPENING_STOPPED_DUE_TO_FIRMWARE_UPDATE", "PRODUCTION_DUMMY_RECORD"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def translations(self):
        """Gets the translations of this LockProtocolEvent.  # noqa: E501

        Event type translations comprising all requested languages (default only \"de-DE\")  # noqa: E501

        :return: The translations of this LockProtocolEvent.  # noqa: E501
        :rtype: dict(str, str)
        """
        return self._translations

    @translations.setter
    def translations(self, translations):
        """Sets the translations of this LockProtocolEvent.

        Event type translations comprising all requested languages (default only \"de-DE\")  # noqa: E501

        :param translations: The translations of this LockProtocolEvent.  # noqa: E501
        :type: dict(str, str)
        """

        self._translations = translations

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LockProtocolEvent, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LockProtocolEvent):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
